<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>SWMM Comparison App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" href="SWMM%20Comparison%20App%20Icon.ico">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/proj4@2.11.0/dist/proj4.js"></script>

  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  <style>
    /* =================================
       GLOBAL & LAYOUT
       ================================= */
    :root { --blue:#05275a; --gray:#7f8c8d; --green:#2ecc71; --red:#e74c3c; --orange:#f39c12;}
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body { font-family: Segoe UI, system-ui, sans-serif; margin:0; color:#222; font-size: 14px; }
    header { display: flex; align-items: center; gap:10px; padding: 0 14px; height: 50px; background:var(--blue); color: #fff; border-bottom:1px solid #e3e3e3; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
    h1 { margin:0; font-size:18px; color: #fff; }
    header img {
      height: 32px;
      width: 32px;
      background: #fff;
      border-radius: 5px;
      padding: 1px;
    }
    header > .btn-group { display:flex; gap: 4px; }
    #wrap { display:grid; grid-template-columns: 340px 5px 1fr; gap:0; padding:12px; height: calc(100vh - 51px); min-height:0; }
    #left { padding-right: 12px; }
    #right { padding-left: 12px; }

    .splitter { background: #eee; }
    .v-splitter { cursor: col-resize; }
    .h-splitter { cursor: row-resize; }
    .v-splitter:hover, .h-splitter:hover { background: var(--blue); }
    body.resizing-v { cursor: col-resize; user-select: none; }
    body.resizing-h { cursor: row-resize; user-select: none; }

    #app-title-group { margin-left: auto; display: flex; align-items: center; gap: 10px; }

    .menu { position: relative; }
    .menu-btn { padding: 6px 12px; border-radius: 6px; cursor: pointer; font-weight: 500; color: #fff; }
    .menu-btn:hover { background-color: #fff; color: #000; }
    /* New Dropdown Menu Styles */
    .menu-content {
      display: none; position: absolute; top: 100%; left: 0; background: #fff;
      border: 1px solid #ccc; box-shadow: 0 4px 8px rgba(0,0,0,0.1); border-radius: 4px; color: #222;
      min-width: 200px; z-index: 1000; padding: 4px;
    }
    .menu:hover .menu-content { display: block; }
    .menu-item { display: block; width: 100%; text-align: left; padding: 8px 12px; border: none; background: none; cursor: pointer; border-radius: 4px; }
    .menu-item:hover { background-color: #eef3ff; color: var(--blue); }
    .menu-content hr { border: none; border-top: 1px solid #eee; margin: 4px 0; }
    .menu-content label { display: block; padding: 8px 12px; }

    button { padding:8px 12px; border-radius:8px; border:1px solid #d0d0d0; background:#fff; cursor:pointer; font-size: 14px; }
    button.primary{ background:#fff; color:var(--blue); border-color:#fff; font-weight: 600; }

    .dropdown-btn, .file-btn-label {
      padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.5); background: transparent; color: #fff; cursor: pointer;
      display: inline-flex; align-items: center; gap: 8px;
    }
    .dropdown-btn::after {
      content: '▼'; font-size: 8px; opacity: 0.6;
    }
    .dropdown-btn:hover, .file-btn-label:hover { background-color: #f8f8f8; color: #222; }

    .diff { background:#fff6e6; border:1px solid #ffe0a8; border-radius:4px; padding:1px 4px; }
    .arrow { opacity:0.75; }

    .panel { border:1px solid #e1e1e1; border-radius:8px; background:#fff; padding:10px; min-height:0; display:flex; flex-direction:column; }
    .panel h3 { margin:0 0 8px 0; font-size:14px; color:#333; }

    #summaryPanel, #sectionsPanel { overflow:auto; }
    #summary, #sections { overflow:auto; min-height:0; }
    #sections .sec { padding:6px 8px; border-radius:6px; cursor:pointer; display:flex; justify-content:space-between; align-items:center; }
    .sec:hover { background:#f6f6f9; }
    .sec.active { background:#eef3ff; border:1px solid #d9e3ff; }
    .counts { color:#666; font-size:12px; }

    #left { display:flex; flex-direction:column; min-height:0; }
    #right { display:flex; flex-direction:column; min-height:0; }

    #filters { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    #search { flex:1; min-width:140px; padding:6px 8px; border:1px solid #ddd; border-radius:6px; }
    #detailsWrap { display:grid; grid-template-columns: 1fr 5px 45%; gap:0; min-height:0; }
    #tableWrap { flex:1; min-width:0; min-height:0; }

    #table { width:100%; border-collapse: collapse; font-size:13px; }
    #table th, #table td { border:1px solid #eee; padding:6px 8px; text-align:left; vertical-align:top; }
    #table th { background:#fafafa; position: sticky; top: 0; z-index:1; }
    #tableContainer { overflow:auto; height:100%; border:1px solid #e1e1e1; border-radius:8px; }
    .removedCell { color:#a52222; }
    .addedCell { color:#1e7b3a; }

    .chip{display:inline-block;width:10px;height:10px;border-radius:2px;margin-right:6px;vertical-align:middle;}
    .legend{position:absolute; bottom:12px; left:12px; background:#fff; padding:10px 12px; border:1px solid #ccc; border-radius:8px; font-size:12px; box-shadow:0 1px 4px rgba(0,0,0,.08);}
    .pill { padding:2px 6px; border-radius:999px; font-size:12px; font-weight:600; }
    .pill.added { background:#eaf7ef; color:#1e7b3a; border:1px solid #cdeed6; }
    .pill.removed { background:#fdeaea; color:#a52222; border:1px solid #f7c7c7; }
    .pill.changed { background:#fff6e6; color:#935c00; border:1px solid #ffe0a8; }
    .row { cursor:pointer; }

    .row.highlighted { background-color: #e0eafb !important; }
    .row:hover { background:#f6f9ff; }
    #status { color:rgba(255,255,255,0.85); }

    #modalBackdrop{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:9999;}
    #modal{background:#fff;border-radius:10px;border:1px solid #ddd;max-width:900px;width:90vw;max-height:80vh;display:flex;flex-direction:column;}
    #modal header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #eee}
    #modal h2{margin:0;font-size:16px}
    #modal .body{padding:10px 14px;overflow:auto}
    #modal .foot{display:flex;gap:8px;justify-content:flex-end;padding:10px 14px;border-top:1px solid #eee}
    .cell-changed{background:#fff6e6;border:1px solid #ffe0a8;border-radius:6px;padding:2px 4px}
    .kv{display:grid;grid-template-columns:200px 1fr 1fr;gap:6px;align-items:start}
    .kv div{padding:6px 8px;border-bottom:1px solid #f2f2f2}
    .kv .hdr{font-weight:600;background:#fafafa}
    .tag{display:inline-block;background:#eef3ff;border:1px solid #d9e3ff;color:#2b579a;border-radius:999px;padding:2px 8px;font-size:12px}

    table.modal-hydro { width:100%; border-collapse:separate; border-spacing:0; }
    table.modal-hydro thead th {
      background:#fafafa; border-bottom:1px solid #eee; padding:8px 10px; text-align:left;
      position:sticky; top:0; z-index:1;
    }
    table.modal-hydro tbody td { padding:6px 10px; border-top:1px solid #f4f4f4; }
    table.modal-hydro tbody tr:nth-child(odd) { background:#fcfcfe; }
    table.modal-hydro .resp { font-weight:600; white-space:nowrap; }
    table.modal-hydro .num { font-variant-numeric: tabular-nums; text-align:right; display:inline-block; min-width:3ch; }
    table.modal-hydro .delta {
      display:inline-flex; align-items:center; gap:6px;
      background:#fff6e6; border:1px solid #ffe0a8; border-radius:8px; padding:2px 6px;
      font-variant-numeric: tabular-nums;
    }
    table.modal-hydro .old { opacity:.75; text-decoration:line-through; }
    table.modal-hydro .arrow { opacity:.6; }
    table.modal-hydro .diff { font-weight:600; }
    table.modal-hydro .plusminus { opacity:.7; }

    /* Desktop-ish legend look */
    .legend-title { font-weight:700; margin-bottom:6px; color:#333; }
    .lg-item { display:flex; align-items:center; gap:8px; margin:4px 0; }
    .lg-swatch { width:16px; height:6px; border-radius:3px; display:inline-block; border:1px solid rgba(0,0,0,.2); }
    .lg-unchanged { background: var(--gray); }
    .lg-changed { background: var(--orange); }
    .lg-added   { background: var(--green); }
    .lg-removed { background: var(--red); }

    #map { min-width:0; min-height:0; border:1px solid #e1e1e1; border-radius:8px; }
    /* Map label badges */
    .map-label {
      background: transparent;
      border: none;
      font-size: 10px;
      color: #000;
      white-space: nowrap;
      text-shadow: 1px 1px 2px #fff, -1px -1px 2px #fff, 1px -1px 2px #fff, -1px 1px 2px #fff;
    }

    input[type=file]{ display: none; } /* Hide default file inputs */
    .file-input-container { display: flex; align-items: center; gap: 8px; }
    .file-name-display {
      font-size: 12px; color: rgba(255,255,255,0.75);
      max-width: 150px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
      cursor: default;
    }

    .help-button {
      width: 28px; height: 28px; border-radius: 50%;
      background: transparent; color: #fff; border: 1px solid rgba(255,255,255,0.7);
      font-weight: bold; font-size: 16px; line-height: 1;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; padding: 0;
    }
    .help-button:hover { background: #fff; color: var(--blue); }
    #helpModal .body ul { padding-left: 20px; margin-top: 0; }
    #helpModal .body li { margin-bottom: 10px; }
  </style>
</head>
<body>
  <header>
    <div class="menu">
      <div class="menu-btn">File</div>
      <div class="menu-content">
        <button id="saveSess" class="menu-item">Save Comparison</button>
        <button id="loadSessBtn" class="menu-item">Load Comparison</button>
        <hr>
        <button id="exportXlsx" class="menu-item">Export to Excel</button>
        <input id="loadSessInput" type="file" accept=".json" />
      </div>
    </div>
    <div class="menu">
      <div class="menu-btn">Map</div>
      <div class="menu-content">
        <label>Basemap:
          <select id="basemapSelect" title="Basemap" style="width:100%; margin-top:4px; padding: 4px;">
            <option value="street" selected>Street</option>
            <option value="aerial">Aerial</option>
            <option value="none">None</option>
          </select>
        </label>
        <hr>
        <label>Coordinate System:
          <select id="crsSelect" title="Coordinate System" style="width:100%; margin-top:4px; padding: 4px;">
            <option value="EPSG:3735" selected>NAD83 / Ohio South (ftUS)</option>
            <option value="EPSG:3733">NAD83 / Ohio North (ftUS)</option>
            <option value="EPSG:6499">NAD83 / Michigan South (ft)</option>
            <option value="EPSG:2272">NAD83 / Pennsylvania South (ftUS)</option>
          </select>
        </label>
        <hr>
        <label class="menu-item"><input type="checkbox" id="labelsToggle" checked> Show Labels</label>
      </div>
    </div>

    <div class="btn-group" style="align-items: center;">
      <div class="file-input-container">
        <label for="f1" class="file-btn-label">First .inp</label>
        <input id="f1" type="file" accept=".inp,.txt" />
        <span id="f1-name" class="file-name-display"></span>
      </div>
      <div class="file-input-container">
        <label for="f2" class="file-btn-label">Second .inp</label>
        <input id="f2" type="file" accept=".inp,.txt" />
        <span id="f2-name" class="file-name-display"></span>
      </div>
    </div>

    <button id="go" class="primary">Compare</button>
    <span id="status"></span>
    <div id="app-title-group">
      <h1>SWMM Comparison App</h1>
      <img src="SWMM%20Comparison%20App%20Icon.ico" alt="App Icon">
      <button id="helpBtn" class="help-button" title="Help">?</button>
    </div>
  </header>

  <script>
    function updateFileName(inputId, spanId) {
      const input = document.getElementById(inputId);
      const span = document.getElementById(spanId);
      input.addEventListener('change', () => span.textContent = input.files[0]?.name || '');
    }
    function openHelpModal() { document.getElementById('helpModalBackdrop').style.display = 'flex'; }
    function closeHelpModal() { document.getElementById('helpModalBackdrop').style.display = 'none'; }
    document.addEventListener('DOMContentLoaded', () => {
      document.getElementById('helpBtn').addEventListener('click', openHelpModal);
    });

    function makeResizable() {
      const vSplitter = document.getElementById('v-splitter');
      const mapSplitter = document.getElementById('map-v-splitter');
      const wrap = document.getElementById('wrap');
      const left = document.getElementById('left');

      vSplitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.body.classList.add('resizing-v');
        const startX = e.clientX;
        const startWidth = left.getBoundingClientRect().width;

        const onMouseMove = (moveEvent) => {
          const newWidth = startWidth + (moveEvent.clientX - startX);
          if (newWidth > 200 && newWidth < (wrap.clientWidth - 400)) {
            wrap.style.gridTemplateColumns = `${newWidth}px 5px 1fr`;
          }
        };
        const onMouseUp = () => {
          document.body.classList.remove('resizing-v');
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', onMouseUp);
        };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp);
      });

      mapSplitter.addEventListener('mousedown', (e) => {
        e.preventDefault();
        document.body.classList.add('resizing-v');
        const detailsWrap = document.getElementById('detailsWrap');
        const startX = e.clientX;
        const startWidth = detailsWrap.querySelector('#tableWrap').getBoundingClientRect().width;

        const onMouseMove = (moveEvent) => {
          const newWidth = startWidth + (moveEvent.clientX - startX);
          if (newWidth > 200 && newWidth < (detailsWrap.clientWidth - 200)) {
            detailsWrap.style.gridTemplateColumns = `${newWidth}px 5px 1fr`;
          }
        };
        const onMouseUp = () => { document.body.classList.remove('resizing-v'); document.removeEventListener('mousemove', onMouseMove); };
        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mouseup', onMouseUp, { once: true });
      });

    }
    document.addEventListener('DOMContentLoaded', makeResizable);

  </script>
  <script>
    // Simple throttle function to limit how often a function can be called.
    function throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      };
    }
  </script>

  <div id="wrap">
    <!-- Left Panel: Sections -->
    <div id="left">
      <div id="sectionsPanel" class="panel">
        <h3>Sections</h3>
        <div id="sections">Run a comparison first.</div>
      </div>
    </div>

    <div id="v-splitter" class="splitter v-splitter"></div>

    <!-- Right Panel: Filters, Table, Map -->
    <div id="right">
      <div class="panel" style="gap:8px;">
        <div id="filters">
          <label><input type="checkbox" id="fAdded" checked> Added</label>
          <label><input type="checkbox" id="fRemoved" checked> Removed</label>
          <label><input type="checkbox" id="fChanged" checked> Changed</label>
          <input id="search" placeholder="Filter rows…" />
          <span id="currentSectionLabel" style="color:#333;font-weight:600;"></span>
        </div>
      </div>

      <div id="detailsWrap" style="flex:1;">
        <div id="tableWrap" class="panel" style="display:flex; flex-direction:column; min-height:0; padding-right: 12px;">
          <h3 style="margin-bottom:8px;">Details</h3>
          <div id="tableContainer"><table id="table"></table></div>
        </div>

        <div id="map-v-splitter" class="splitter v-splitter"></div>

        <div id="map" class="panel" style="padding-left: 12px;"></div>
      </div>
    </div>
  </div>

  <template id="legend">
    <div class="legend">
      <div class="legend-title">Map Legend</div>
      <div class="lg-item"><span class="lg-swatch lg-unchanged"></span><span>Unchanged</span></div>
      <div class="lg-item"><span class="lg-swatch lg-changed"></span><span>Changed</span></div>
      <div class="lg-item"><span class="lg-swatch lg-added"></span><span>Added</span></div>
      <div class="lg-item"><span class="lg-swatch lg-removed"></span><span>Removed</span></div>
    </div>
  </template>
  <div id="modalBackdrop" onclick="if(event.target===this) closeModal()">
    <div id="modal" role="dialog" aria-modal="true">
      <header>
        <h2 id="modalTitle">Details</h2>
        <button onclick="closeModal()">Close</button>
      </header>
      <div class="body">
        <div id="modalMeta" style="margin-bottom:8px;color:#555;"></div>
        <div class="kv" id="modalGrid"></div>
      </div>
      <div class="foot">
        <label style="margin-right:auto"><input type="checkbox" id="onlyChangedBox" /> Show changed fields only</label>
        <button onclick="copyRowJSON()">Copy JSON</button>
      </div>
    </div>
  </div>

  <div id="helpModalBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:10000;" onclick="if(event.target===this) closeHelpModal()">
    <div id="helpModal" style="background:#fff;border-radius:10px;border:1px solid #ddd;max-width:600px;width:90vw;max-height:80vh;display:flex;flex-direction:column;">
      <header style="display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid #eee">
        <h2 style="margin:0;font-size:16px">How to Use This App</h2>
        <button onclick="closeHelpModal()">Close</button>
      </header>
      <div class="body" style="padding:10px 14px;overflow:auto">
        <p>This application helps you compare two SWMM .inp files to identify differences in their structure and parameters. This application is still in testing and may miss edge cases not yet covered by the comparison.</p>
        <ul>
          <li><strong>Load SWMM .inp Files:</strong> Use the "First .inp" and "Second .inp" buttons to select your two model files, then click "Compare".</li>
          <li><strong>File Menu:</strong> Use the "File" dropdown to save the current comparison, load a previous one, or export the differences to an Excel file.</li>
          <li><strong>Map Adjustments:</strong> Use the "Map" dropdown to adjust visualization, change coordinate systems, and turn map labels on and off.</li>
          <li><strong>Explore Sections:</strong> Click a section in the "Sections" panel to view detailed changes in the table on the right.</li>
          <li><strong>Interact with the Table:</strong>
            <ul style="margin-top: 10px;">
              <li><strong>Single-click</strong> a row in the details table to automatically pan and zoom the map to that element, highlighting it in cyan.</li>
              <li><strong>Double-click</strong> a row to open a detailed pop-up window showing the old and new values for that specific element side-by-side.</li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    const PROJECTIONS = {
      "EPSG:3735": "+proj=lcc +lat_0=38 +lon_0=-82.5 +lat_1=40.0333333333333 +lat_2=38.7333333333333 +x_0=600000 +y_0=0 +ellps=GRS80 +units=us-ft +no_defs +type=crs",
      "EPSG:3733": "+proj=lcc +lat_0=39.6666666666667 +lon_0=-82.5 +lat_1=41.7 +lat_2=40.4333333333333 +x_0=600000 +y_0=0 +ellps=GRS80 +units=us-ft +no_defs +type=crs",
      "EPSG:6499": "+proj=lcc +lat_0=41.5 +lon_0=-84.3666666666667 +lat_1=43.6666666666667 +lat_2=42.1 +x_0=3999999.999984 +y_0=0 +ellps=GRS80 +units=ft +no_defs +type=crs",
      "EPSG:2272": "+proj=lcc +lat_0=39.33333333333334 +lon_0=-77.75 +lat_1=40.96666666666667 +lat_2=39.93333333333333 +x_0=600000.00012192 +y_0=0.000121915682 +datum=NAD83 +units=us-ft +no_defs +type=crs"
    };

    let CURRENT_CRS = "EPSG:3735";
    proj4.defs(CURRENT_CRS, PROJECTIONS[CURRENT_CRS]);
    const XY_LATLNG_CACHE = new Map();

    document.getElementById('crsSelect').addEventListener('change', (e) => {
      CURRENT_CRS = e.target.value;
      proj4.defs(CURRENT_CRS, PROJECTIONS[CURRENT_CRS]);
      XY_LATLNG_CACHE.clear();
      if (LAST.json) {
        drawGeometry(LAST.json);
      }
    });

    const SESSION_VERSION = 1;
    let FILES = { f1Name:null, f2Name:null, f1Bytes:null, f2Bytes:null };

    function abToB64(ab) {
      const bytes = new Uint8Array(ab);
      let binary = '';
      const chunkSize = 0x8000; // 32 KB chunks
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.subarray(i, i + chunkSize);
        binary += String.fromCharCode.apply(null, chunk);
      }
      return btoa(binary);
    }

    function b64ToAb(b64){
      const bin = atob(b64);
      const ab = new ArrayBuffer(bin.length);
      const view = new Uint8Array(ab);
      for (let i=0;i<bin.length;i++) view[i] = bin.charCodeAt(i);
      return ab;
    }

    async function saveSession(){
      if (!LAST.json) { alert("Run a comparison first."); return; }

      const session = {
        version: SESSION_VERSION,
        createdUtc: new Date().toISOString(),
        files: {
          file1: FILES.f1Bytes ? { name: FILES.f1Name, bytesB64: abToB64(FILES.f1Bytes) } : null,
          file2: FILES.f2Bytes ? { name: FILES.f2Name, bytesB64: abToB64(FILES.f2Bytes) } : null,
        },
        result: LAST.json,
        ui: {
          section: LAST.currentSection || null,
          crs: CURRENT_CRS,
          filters: {
            Added:   document.getElementById('fAdded').checked,
            Removed: document.getElementById('fRemoved').checked,
            Changed: document.getElementById('fChanged').checked,
            Search:  document.getElementById('search').value || ""
          }
        }
      };

      const blob = new Blob([JSON.stringify(session, null, 2)], { type: "application/json" });

      if (window.showSaveFilePicker) {
        try {
          const handle = await window.showSaveFilePicker({
            suggestedName: `inp_diff_session_${Date.now()}.json`,
            types: [{
              description: 'INP Diff Session',
              accept: { 'application/json': ['.json'] }
            }]
          });
          const writable = await handle.createWritable();
          await writable.write(blob);
          await writable.close();
          setStatus("Session saved.");
        } catch (err) {
          if (err.name !== 'AbortError') console.error("Save failed:", err);
        }
      } else {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `inp_diff_session_${Date.now()}.json`;
        a.click();
        URL.revokeObjectURL(url);
      }
    }

    function applyUIState(ui){
      if (!ui) return;
      const f = ui.filters;
      document.getElementById('fAdded').checked   = f?.Added   ?? true;
      document.getElementById('fRemoved').checked = f?.Removed ?? true;
      document.getElementById('fChanged').checked = f?.Changed ?? true;
      if (typeof f.Search  === 'string')   document.getElementById('search').value = f.Search;

      if (ui.crs && PROJECTIONS[ui.crs]) {
        document.getElementById('crsSelect').value = ui.crs;
        document.getElementById('crsSelect').dispatchEvent(new Event('change'));
      }
    }

    function relabelHeaders(section, hdrs){
      if (section !== "INFILTRATION") return hdrs;
      const MAP = {
        "Param1": "Max. Infil. Rate",
        "Param 1": "Max. Infil. Rate",
        "Param2": "Min. Infil. Rate",
        "Param 2": "Min. Infil. Rate",
        "Param3": "Decay Constant",
        "Param 3": "Decay Constant",
        "Param4": "Drying Time",
        "Param 4": "Drying Time",
        "Param5": "Max. Volume",
        "Param 5": "Max. Volume",
      };
      return hdrs.map(h => MAP[h] ?? h);
    }

    function restoreFromResult(result, ui){
      LAST.json = result;
      applyUIState(ui); // Apply UI state (including CRS) first
      renderSections(result);
      drawGeometry(result);
      if (ui?.section && result.diffs[ui.section]) {
        LAST.currentSection = ui.section;
        document.getElementById('currentSectionLabel').textContent = ui.section;
        renderTableFor(ui.section);
        const node = [...document.querySelectorAll('.sec')].find(n => n.dataset.sec === ui.section);
        document.querySelectorAll('.sec').forEach(n=>n.classList.remove('active'));
        node?.classList.add('active');
      }
      setStatus("Session loaded.");
    }

    async function loadSession(file){
      try {
        const text = await file.text();
        const session = JSON.parse(text);

        FILES = { f1Name:null, f2Name:null, f1Bytes:null, f2Bytes:null };
        if (session.files?.file1?.bytesB64) {
          FILES.f1Name  = session.files.file1.name || "file1.inp";
          FILES.f1Bytes = b64ToAb(session.files.file1.bytesB64);
        }
        if (session.files?.file2?.bytesB64) {
          FILES.f2Name  = session.files.file2.name || "file2.inp";
          FILES.f2Bytes = b64ToAb(session.files.file2.bytesB64);
        }

        document.getElementById('f1-name').textContent = FILES.f1Name || '';
        document.getElementById('f2-name').textContent = FILES.f2Name || '';

        if (session.result) {
          restoreFromResult(session.result, session.ui);
        } else if (FILES.f1Bytes && FILES.f2Bytes) {
          setStatus("Recomputing comparison from saved INP files…");
          worker.postMessage({ type:"compare", file1: FILES.f1Bytes, file2: FILES.f2Bytes }, [FILES.f1Bytes, FILES.f2Bytes]);
        } else {
          alert("Session file has no result data and no embedded INP files. Please select the INP files and run Compare.");
        }
      } catch (e) {
        console.error(e);
        alert("Could not load session: " + e.message);
      }
    }

    document.getElementById('saveSess').addEventListener('click', saveSession);
    document.getElementById('loadSessBtn').addEventListener('click', ()=> document.getElementById('loadSessInput').click());
    document.getElementById('loadSessInput').addEventListener('change', (ev)=>{
      const f = ev.target.files?.[0];
      if (f) loadSession(f);
    });

    async function exportToExcel() {
      if (!LAST.json) { alert("Please run a comparison first."); return; }
      setStatus("Generating Excel file...");
      await new Promise(resolve => setTimeout(resolve, 50));

      const wb = XLSX.utils.book_new();
      const { diffs, headers } = LAST.json;

      // Define styles
      const styles = {
        header: { font: { bold: true }, fill: { fgColor: { rgb: "FFFAFAFA" } } },
        added:  { fill: { fgColor: { rgb: "FFEAF7EF" } }, font: { color: { rgb: "FF1E7B3A" } } },
        removed:{ fill: { fgColor: { rgb: "FFFDEAEA" } }, font: { color: { rgb: "FFA52222" } } },
        changed:{ fill: { fgColor: { rgb: "FFFFF6E6" } }, font: { color: { rgb: "FF935C00" } } },
        pillAdded:  { fill: { fgColor: { rgb: "FFCDEED6" } }, font: { bold: true, color: { rgb: "FF1E7B3A" } } },
        pillRemoved:{ fill: { fgColor: { rgb: "FFF7C7C7" } }, font: { bold: true, color: { rgb: "FFA52222" } } },
        pillChanged:{ fill: { fgColor: { rgb: "FFFFE0A8" } }, font: { bold: true, color: { rgb: "FF935C00" } } },
      };

      for (const sec of Object.keys(diffs).sort()) {
        const d = diffs[sec];
        let sheetData = [];
        let hdrs = headers[sec] ? [...headers[sec]] : [];

        if (sec === "HYDROGRAPHS") {
          hdrs = ["Hydrograph", "Month", "Change Type"];
          sheetData.push(["Element ID", "Change", ...hdrs]);
          const rows = groupHydroSummary(d);
          rows.forEach(r => {
            sheetData.push([`${r.hydro} ${r.month}`, r.changeType.includes("Added") || r.changeType.includes("Removed") ? r.changeType.split(',')[0] : "Changed", r.hydro, r.month, r.changeType]);
          });
        } else {
          hdrs = relabelHeaders(sec, hdrs);
          sheetData.push(["Element ID", "Change", ...hdrs]);

          const rows = [];
          for (const [id, arr] of Object.entries(d.added || {})) rows.push({type:'Added', id, oldArr:[], newArr:arr});
          for (const [id, arr] of Object.entries(d.removed || {})) rows.push({type:'Removed', id, oldArr:arr, newArr:[]});
          for (const [id, pair] of Object.entries(d.changed || {})) rows.push({type:'Changed', id, oldArr:pair[0], newArr:pair[1]});
          rows.sort((a,b) => a.id.localeCompare(b.id));

          rows.forEach(r => {
            const row = [r.id, r.type];
            const oldA = [r.id, ...r.oldArr];
            const newA = [r.id, ...r.newArr];

            for (let i = 0; i < hdrs.length; i++) {
              const ov = oldA[i] ?? "";
              const nv = newA[i] ?? "";

              if (r.type === 'Added') row.push(nv);
              else if (r.type === 'Removed') row.push(ov);
              else row.push(ov === nv ? nv : `${ov} → ${nv}`);
            }
            sheetData.push(row);
          });
        }

        const ws = XLSX.utils.aoa_to_sheet(sheetData);

        const colWidths = sheetData[0].map(h => h.length);
        for (let R = 0; R < sheetData.length; ++R) {
          for (let C = 0; C < sheetData[R].length; ++C) {
            const cell_address = { c: C, r: R };
            const cell_ref = XLSX.utils.encode_cell(cell_address);
            if (!ws[cell_ref]) continue;

            const cellValue = sheetData[R][C]?.toString() || "";
            if (cellValue.length > colWidths[C]) colWidths[C] = cellValue.length;

            if (R === 0) {
              ws[cell_ref].s = styles.header;
            } else if (C === 1) {
              const changeType = sheetData[R][C];
              if (changeType.includes('Added')) ws[cell_ref].s = styles.pillAdded;
              else if (changeType.includes('Removed')) ws[cell_ref].s = styles.pillRemoved;
              else ws[cell_ref].s = styles.pillChanged;
            } else if (sec !== "HYDROGRAPHS" && C > 1) {
              const changeType = sheetData[R][1];
              if (changeType === 'Added') ws[cell_ref].s = styles.added;
              else if (changeType === 'Removed') ws[cell_ref].s = styles.removed;
              else if (cellValue.includes('→')) ws[cell_ref].s = styles.changed;
            }
          }
        }
        ws['!cols'] = colWidths.map(w => ({ wch: Math.min(w + 2, 60) }));

        const sheetName = sec.replace(/[:\\/?*[\]]/g, "").substring(0, 31);
        XLSX.utils.book_append_sheet(wb, ws, sheetName);
      }

      const f1Name = document.getElementById('f1-name').textContent || "file1";
      const f2Name = document.getElementById('f2-name').textContent || "file2";
      const filename = `SWMM_Compare_${f1Name}_vs_${f2Name}.xlsx`;

      XLSX.writeFile(wb, filename);
      setStatus("Excel file generated.");
    }

    document.getElementById('exportXlsx').addEventListener('click', exportToExcel);

    updateFileName('f1', 'f1-name');
    updateFileName('f2', 'f2-name');

    document.getElementById('go').addEventListener('click', async ()=>{
      const f1 = document.getElementById('f1').files?.[0];
      const f2 = document.getElementById('f2').files?.[0];
      if (!f1 || !f2) return;
      FILES.f1Name = f1.name; FILES.f2Name = f2.name;
      const [b1, b2] = await Promise.all([f1.arrayBuffer(), f2.arrayBuffer()]);
      FILES.f1Bytes = b1; FILES.f2Bytes = b2;
      
    }); // This is the duplicate 'go' event listener, removing it.
    let LAST = { json:null, currentSection:null }; // Moved LAST declaration here to ensure it's initialized early.
    // Use canvas renderer for better performance with large datasets
    const map = L.map('map', { zoomControl:true, maxZoom: 22, renderer: L.canvas() }).setView([39.1031, -84.5120], 12);

    // Create panes to control rendering order (subs < links < nodes)
    map.createPane('subcatchmentPane').style.zIndex = 380;
    map.createPane('linkPane').style.zIndex = 390;
    map.createPane('nodePane').style.zIndex = 410; // Above default overlayPane (400)


    const baseLayers = {
      street: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution:"&copy; OpenStreetMap"
      }),
      aerial: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles &copy; Esri'
      })
    };
    let activeBase = null;
    function setBasemap(which){
      if (activeBase) map.removeLayer(activeBase);
      if (which === 'none'){ activeBase = null; return; }
      activeBase = baseLayers[which] || baseLayers.street;
      activeBase.addTo(map);
    }
    setBasemap('street');
    document.getElementById('basemapSelect').addEventListener('change', (e)=> setBasemap(e.target.value));

    map.addControl(new (L.Control.extend({ onAdd(){ return document.getElementById('legend').content.firstElementChild.cloneNode(true); } }))({ position:"bottomleft" }));

    let layers = {
      nodes: { unchanged: L.layerGroup().addTo(map), changed: L.layerGroup().addTo(map), added: L.layerGroup().addTo(map), removed: L.layerGroup().addTo(map) },
      links: { unchanged: L.layerGroup().addTo(map), changed: L.layerGroup().addTo(map), added: L.layerGroup().addTo(map), removed: L.layerGroup().addTo(map) },
      subs:  { unchanged: L.layerGroup().addTo(map), changed: L.layerGroup().addTo(map), added: L.layerGroup().addTo(map), removed: L.layerGroup().addTo(map) },
      select: L.layerGroup().addTo(map)
    };
    const C = { unchanged:"#7f8c8d", changed:"#f39c12", added:"#2ecc71", removed:"#e74c3c", select:"#00FFFF" };

    function resetLayers() {
      Object.values(layers).forEach(groupSet=>{
        if (groupSet instanceof L.LayerGroup) { groupSet.clearLayers(); return; }
        Object.values(groupSet).forEach(g=>g.clearLayers());
      });
    }

    function xyToLatLng(x, y) {
      const [lon, lat] = proj4(CURRENT_CRS, "EPSG:4326", [x, y]);
      return [lat, lon];
    }

    function coordsToLatLng(coords) {
      return coords.map(p => xyToLatLng(p[0], p[1]));
    }

    const secType = (sec) => (["JUNCTIONS","OUTFALLS","DIVIDERS","STORAGE"].includes(sec) ? "nodes" :
                              ["CONDUITS","PUMPS","ORIFICES","WEIRS","OUTLETS"].includes(sec) ? "links" :
                              sec==="SUBCATCHMENTS" ? "subs" : null);

    function buildSets(diffs, renames) {
      const sets = {
        nodes:{added:new Set(), removed:new Set(), changed:new Set(), base:new Set()},
        links:{added:new Set(), removed:new Set(), changed:new Set(), base:new Set()},
        subs:{added:new Set(), removed:new Set(), changed:new Set(), base:new Set()}
      };
      for (const [sec, d] of Object.entries(diffs)) {
        const t = secType(sec); if (!t) continue;
        Object.keys(d.added || {}).forEach(id => sets[t].added.add(id));
        Object.keys(d.removed || {}).forEach(id => sets[t].removed.add(id));
        Object.keys(d.changed || {}).forEach(id => sets[t].changed.add(id));
      }
      for (const [sec, mapping] of Object.entries(renames||{})) {
        const t = secType(sec); if (!t) continue;
        Object.keys(mapping).forEach(oldId => sets[t].changed.add(oldId));
      }
      return sets;
    }

    const labelsLayer = L.layerGroup().addTo(map);
    const LABEL_ZOOM_THRESHOLD = 17;

    function midOfLine(coords){
      if (!coords || coords.length === 0) return null;
      if (coords.length === 1) return coords[0];
      const segs = [];
      let total = 0;
      for (let i=1; i<coords.length; i++){
        const a = coords[i-1], b = coords[i];
        const dx = b[0] - a[0], dy = b[1] - a[1];
        const len = Math.hypot(dx, dy);
        segs.push({a, b, len});
        total += len;
      }
      const half = total / 2;
      let acc = 0;
      for (const s of segs){
        if (acc + s.len >= half){
          const t = (half - acc) / (s.len || 1);
          return [ s.a[0] + t*(s.b[0]-s.a[0]), s.a[1] + t*(s.b[1]-s.a[1]) ];
        }
        acc += s.len;
      }
      return coords[Math.floor(coords.length/2)];
    }

    function centroidOfPoly(coords){
      if (!coords || coords.length === 0) return null;
      let x = 0, y = 0;
      for (const p of coords){ x += p[0]; y += p[1]; }
      return [x/coords.length, y/coords.length];
    }

    function drawLabels(json){
      labelsLayer.clearLayers();
      if (!document.getElementById('labelsToggle').checked) return;
      if (map.getZoom() < LABEL_ZOOM_THRESHOLD) return;

      const geom = json.geometry;
      const bounds = map.getBounds();

      const nodeKeys = new Set([...(Object.keys(geom.nodes2||{})), ...(Object.keys(geom.nodes1||{}))]);
      nodeKeys.forEach(id=>{
        const xy = (geom.nodes2 && geom.nodes2[id]) || (geom.nodes1 && geom.nodes1[id]);
        if (!xy) return;
        const ll = xyToLatLng(xy[0], xy[1]);
        if (bounds.contains(ll)) {
          L.tooltip({ permanent: true, direction: 'top', className: 'map-label', offset: [0, -5] })
            .setLatLng(ll).setContent(id).addTo(labelsLayer);
        }
      });

      const subKeys = new Set([...(Object.keys(geom.subs2||{})), ...(Object.keys(geom.subs1||{}))]);
      subKeys.forEach(id=>{
        const coords = (geom.subs2 && geom.subs2[id]) || (geom.subs1 && geom.subs1[id]);
        if (!coords || coords.length < 3) return;
        const centerXY = centroidOfPoly(coords);
        const ll = xyToLatLng(centerXY[0], centerXY[1]);
        if (bounds.contains(ll)) {
          L.tooltip({ permanent: true, direction: 'center', className: 'map-label' }).setLatLng(ll).setContent(id).addTo(labelsLayer);
        }
      });
    }

    document.getElementById('labelsToggle').addEventListener('change', ()=>{
      if (!LAST.json) return;
      throttledDrawLabels();
    });

    const NODE_ICON_CACHE = new Map();

    const throttledDrawLabels = throttle(() => {
      if (!LAST.json) return;
      drawLabels(LAST.json);
    }, 200);

    map.on('zoomend moveend', throttledDrawLabels);

    function drawGeometry(json) {
      resetLayers();
      const geom = json.geometry;
      const sets = buildSets(json.diffs, json.renames);

      const collectBase = (obj1,obj2)=> new Set([...Object.keys(obj1||{}), ...Object.keys(obj2||{})]);
      sets.nodes.base = collectBase(json.geometry.nodes1, json.geometry.nodes2);
      sets.links.base = collectBase(json.geometry.links1, json.geometry.links2);
      sets.subs.base  = collectBase(json.geometry.subs1,  json.geometry.subs2);

      const unchanged = {
        nodes:new Set([...sets.nodes.base].filter(x=>!sets.nodes.added.has(x)&&!sets.nodes.removed.has(x)&&!sets.nodes.changed.has(x))),
        links:new Set([...sets.links.base].filter(x=>!sets.links.added.has(x)&&!sets.links.removed.has(x)&&!sets.links.changed.has(x))),
        subs: new Set([...sets.subs.base ].filter(x=>!sets.subs.added.has(x) &&!sets.subs.removed.has(x) &&!sets.subs.changed.has(x)))
      };

      const nodeSections = ["JUNCTIONS", "OUTFALLS", "DIVIDERS", "STORAGE"];
      const nodeIdToSection = {};
      // Build a complete map of all node IDs to their section by looking in the original parsed sections from file 1.
      // This is necessary to correctly identify the type of UNCHANGED nodes.
      for (const sec of nodeSections) {
        if (json.sections1 && json.sections1[sec]) {
          for (const id in json.sections1[sec]) {
            nodeIdToSection[id] = sec;
          }
        }
      }

      const drawNode=(id,xy,color,target)=>{
        const ll = xyToLatLng(xy[0],xy[1]);
        // Use circleMarker for performance. It renders on canvas.
        const sec = nodeIdToSection[id] || "JUNCTIONS";
        const marker = L.circleMarker(ll, {
          radius: 5, color: "#000", weight: 1, fillColor: color, fillOpacity: 1, pane: 'nodePane'
        });
        marker.swmmInfo = { id, section: sec, type: 'node' };
        marker.addTo(layers.nodes[target]);
      };

      const linkIdToSection = {};
      const linkSections = ["CONDUITS", "PUMPS", "ORIFICES", "WEIRS", "OUTLETS"];
      for (const sec of linkSections) {
        if (json.sections1 && json.sections1[sec]) for (const id in json.sections1[sec]) linkIdToSection[id] = sec;
        if (json.sections2 && json.sections2[sec]) for (const id in json.sections2[sec]) linkIdToSection[id] = sec;
      }

      const drawLink=(id,coords,color,target)=>{
        const ll=coords.map(p=>xyToLatLng(p[0],p[1]));
        const polyline = L.polyline(ll,{color,weight:3,opacity:.95, pane: 'linkPane'});
        const sec = linkIdToSection[id] || 'CONDUITS'; // Default to CONDUITS if not found
        polyline.swmmInfo = { id, section: sec, type: 'link' };
        polyline.addTo(layers.links[target]);
      };
      const drawSub=(id,coords,color,target)=>{
        const ll=coords.map(p=>xyToLatLng(p[0],p[1]));
        const polygon = L.polygon(ll,{color,weight:2,fill:true,fillOpacity:.25, pane: 'subcatchmentPane'});
        polygon.swmmInfo = { id, section: 'SUBCATCHMENTS', type: 'sub' };
        polygon.addTo(layers.subs[target]);
      };

      for (const id of unchanged.nodes) if (geom.nodes1?.[id]) drawNode(id, geom.nodes1[id], C.unchanged, "unchanged");
      for (const id of sets.nodes.removed) if (geom.nodes1?.[id]) drawNode(id, geom.nodes1[id], C.removed, "removed");
      for (const id of unchanged.links) if (geom.links1?.[id]) drawLink(id, geom.links1[id], C.unchanged, "unchanged");
      for (const id of sets.links.removed) if (geom.links1?.[id]) drawLink(id, geom.links1[id], C.removed, "removed");
      for (const id of unchanged.subs) if (geom.subs1?.[id]) drawSub(id, geom.subs1[id], C.unchanged, "unchanged");
      for (const id of sets.subs.removed) if (geom.subs1?.[id]) drawSub(id, geom.subs1[id], C.removed, "removed");

      for (const id of sets.nodes.changed) { const xy=geom.nodes2?.[id]; if (xy) drawNode(id, xy, C.changed, "changed");}
      for (const id of sets.nodes.added) if (geom.nodes2?.[id]) drawNode(id, geom.nodes2[id], C.added, "added");
      for (const id of sets.links.changed) { const ll=geom.links2?.[id]; if (ll) drawLink(id, ll, C.changed, "changed"); }
      for (const id of sets.links.added) if (geom.links2?.[id]) drawLink(id, geom.links2[id], C.added, "added");

      for (const id of sets.subs.changed) { const poly=geom.subs2?.[id]; if (poly) drawSub(id, poly, C.changed, "changed"); }
      for (const id of sets.subs.added) if (geom.subs2?.[id]) drawSub(id, geom.subs2[id], C.added, "added");

      const anyLL=[];
      const pushAll=(g)=>{ if(!g) return; Object.values(g).forEach(v=>{ if(Array.isArray(v)&&v.length&&Array.isArray(v[0])){ coordsToLatLng(v).forEach(p=>anyLL.push(p));} else if(Array.isArray(v)){ anyLL.push(xyToLatLng(v[0],v[1])); }}); };
      pushAll(geom.nodes1); pushAll(geom.nodes2); pushAll(geom.links1); pushAll(geom.links2); pushAll(geom.subs1); pushAll(geom.subs2);
      if (anyLL.length) map.fitBounds(L.latLngBounds(anyLL), { padding:[20,20] });

      throttledDrawLabels();
    }

    function groupHydroSummary(d) {
      const allKeys = new Set([
        ...Object.keys(d.added || {}),
        ...Object.keys(d.removed || {}),
        ...Object.keys(d.changed || {})
      ]);
      const grouped = new Map();
      for (const k of allKeys) {
        const parts = k.split(" ");
        const hydro = parts[0] || "";
        const month = parts[1] || "";
        const gkey = `${hydro} ${month}`;
        if (!grouped.has(gkey)) grouped.set(gkey, new Set());
        const s = grouped.get(gkey);
        if (d.added && (k in d.added)) s.add("Added");
        if (d.removed && (k in d.removed)) s.add("Removed");
        if (d.changed && (k in d.changed)) s.add("Changed");
      }
      const rows = [];
      for (const [gkey, set] of grouped.entries()) {
        const [hydro, month] = gkey.split(" ");
        rows.push({ id: gkey, hydro, month, changeType: [...set].sort().join(", ") || "—" });
      }
      rows.sort((a,b)=> (a.hydro+b.month).localeCompare(b.hydro+b.month));
      return rows;
    }

    function renderSections(json){
      const diffs = json.diffs || {};
      const cont = document.getElementById('sections');
      const items = [];
      for (const sec of Object.keys(diffs).sort()){
        const d = diffs[sec];
        const added   = Object.keys(d.added || {}).length;
        const removed = Object.keys(d.removed || {}).length;
        const changed = Object.keys(d.changed || {}).length;
        items.push({ sec, added, removed, changed });
      }
      if (!items.length){ cont.textContent = "No sections with differences."; return; }
      cont.innerHTML = "";
      items.forEach(({sec, added, removed, changed})=>{
        const div = document.createElement('div');
        div.className = 'sec';
        div.dataset.sec = sec;
        div.innerHTML = `<span>${sec}</span>
          <span class="counts">
            <span class="pill added">+${added}</span>
            <span class="pill removed">-${removed}</span>
            <span class="pill changed">⚙${changed}</span>
          </span>`;
        div.onclick = ()=>{
          document.querySelectorAll('.sec').forEach(n=>n.classList.remove('active'));
          div.classList.add('active');
          LAST.currentSection = sec;
          document.getElementById('currentSectionLabel').textContent = sec;
          renderTableFor(sec);
        };
        cont.appendChild(div);
      });
      cont.firstChild?.click();
    }

    function passChangeFilter(changeType){
      const m = { Added:'fAdded', Removed:'fRemoved', Changed:'fChanged' };
      const id = m[changeType] || null;
      if (!id) return true;
      return document.getElementById(id).checked;
    }

    function renderTableFor(sec){
      const table = document.getElementById('table');
      const { diffs, headers } = LAST.json;
      const d = diffs[sec] || { added:{}, removed:{}, changed:{} };
      const q = document.getElementById('search').value.trim().toLowerCase();

      if (sec === "HYDROGRAPHS") {
        const rows = groupHydroSummary(d);
        const hdrs = ["Hydrograph","Month","ChangeType"];

        let thead = `<thead><tr><th style="width:180px">ElementID</th><th style="width:110px">Change</th>`;
        for (const h of hdrs) thead += `<th>${escapeHtml(h)}</th>`;
        thead += `</tr></thead>`;

        const fAdded = document.getElementById('fAdded').checked;
        const fRemoved = document.getElementById('fRemoved').checked;
        const fChanged = document.getElementById('fChanged').checked;

        const filtered = rows.filter(r => {
          const changeText = r.changeType.toLowerCase();
          const matchesFilter = (fAdded && changeText.includes('added')) || (fRemoved && changeText.includes('removed')) || (fChanged && changeText.includes('changed'));
          const matchesSearch = !q || (`${r.id} ${r.changeType}`).toLowerCase().includes(q);
          return matchesFilter && matchesSearch;
        });

        const body = [];
        for (const r of filtered) {
          const type = r.changeType === "Added" || r.changeType === "Removed" ? r.changeType : "Changed";
          const pill = type.toLowerCase();
          let tr = `<tr class="row" data-hydro="${escapeHtml(r.hydro)}" data-month="${escapeHtml(r.month)}">`;
          tr += `<td>${escapeHtml(`${r.hydro} ${r.month}`)}</td>`;
          tr += `<td><span class="pill ${pill}">${type}</span></td>`;
          tr += `<td>${escapeHtml(r.hydro)}</td><td>${escapeHtml(r.month)}</td><td>${escapeHtml(r.changeType)}</td>`;
          tr += `</tr>`;
          body.push(tr);
        }

        table.innerHTML = thead + `<tbody>${body.join("") || `<tr><td colspan="${hdrs.length+2}" style="color:#666;font-style:italic;">No rows match.</td></tr>`}</tbody>`;

        table.querySelectorAll('tbody tr').forEach((tr)=>{
          const hydro = tr.dataset.hydro;
          const month = tr.dataset.month;
          tr.onclick  = ()=> highlightElement(sec, `${hydro} ${month}`);
          tr.ondblclick = ()=> openDetail("HYDROGRAPHS", `${hydro} ${month}`);
        });
        return;
      }

      const hdrs = headers[sec] || [];
      const hdrsLabeled = relabelHeaders(sec, hdrs);

      const rows = [];
      const push = (type, id, oldArr, newArr) => rows.push({type,id,oldArr:(oldArr||[]),newArr:(newArr||[])});

      for (const [id, arr] of Object.entries(d.added || {})) if (passChangeFilter('Added')) push('Added', id, [], arr);
      for (const [id, arr] of Object.entries(d.removed || {})) if (passChangeFilter('Removed')) push('Removed', id, arr, []);
      for (const [id, pair] of Object.entries(d.changed || {})) if (passChangeFilter('Changed')) push('Changed', id, pair[0], pair[1]);

      const filt = q ? rows.filter(r => (r.id+' '+r.type+' '+r.oldArr.join(' ')+' '+r.newArr.join(' ')).toLowerCase().includes(q)) : rows;

      let thead = `<thead><tr><th style="width:180px">ElementID</th><th style="width:110px">Change</th>`;
      for (const h of hdrsLabeled) thead += `<th>${escapeHtml(h)}</th>`;
      thead += `</tr></thead>`;

      const tbodyParts = [];
      for (const r of filt){
        const pill = r.type.toLowerCase();
        let tr = `<tr class="row">`;
        tr += `<td>${escapeHtml(r.id)}</td>`;
        tr += `<td><span class="pill ${pill}">${r.type}</span></td>`;

        const len = hdrsLabeled.length;
        let oldA, newA;

        if (sec === "HYDROGRAPHS") {
          const parts = r.id.split(' ');
          const hydrograph = parts[0] || '';
          const month = parts[1] || '';
          const response = parts.slice(2).join(' ') || '';
          oldA = [hydrograph, month, response, ...r.oldArr];
          newA = [hydrograph, month, response, ...r.newArr];
        } else {
          oldA = [r.id, ...r.oldArr];
          newA = [r.id, ...r.newArr];
        }

        while (oldA.length < len) oldA.push("");
        while (newA.length < len) newA.push("");

        for (let i=0;i<len;i++){
          const ov = oldA[i] ?? "";
          const nv = newA[i] ?? "";
          if (r.type === "Added")      tr += `<td class="addedCell">${escapeHtml(nv)}</td>`;
          else if (r.type === "Removed") tr += `<td class="removedCell">${escapeHtml(ov)}</td>`;
          else tr += (ov !== nv)
            ? `<td><span class="diff">${escapeHtml(ov)} <span class="arrow">→</span> ${escapeHtml(nv)}</span></td>`
            : `<td>${escapeHtml(nv)}</td>`;
        }
        tr += `</tr>`;
        tbodyParts.push(tr);
      }

      table.innerHTML = thead + `<tbody>${tbodyParts.join("") || `<tr><td colspan="${hdrsLabeled.length+2}" style="color:#666;font-style:italic;">No rows match.</td></tr>`}</tbody>`;

      table.querySelectorAll('tbody tr').forEach((tr)=>{
        const id = tr.children[0]?.textContent || "";
        tr.onclick = ()=> highlightElement(sec, id);
        tr.classList.add(`row-id-${id.replace(/[^a-zA-Z0-9]/g, '_')}`);
        tr.addEventListener('highlight', () => tr.scrollIntoView({ behavior: 'smooth', block: 'center' }));

        tr.ondblclick = ()=> openDetail(sec, id);
      });
    }

    function escapeHtml(s){ return (s||"").replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"}[c])); }
    function highlightElement(section, id){
      layers.select.clearLayers();

      // Highlight table row
      document.querySelectorAll('#table .row.highlighted').forEach(r => r.classList.remove('highlighted'));
      const safeId = id.replace(/[^a-zA-Z0-9]/g, '_');
      const row = document.querySelector(`#table .row-id-${safeId}`);
      if (row) { row.classList.add('highlighted'); row.dispatchEvent(new Event('highlight')); }

      const t = secType(section);
      if (!t) return;

      const g1 = LAST.json.geometry[ t === 'nodes' ? 'nodes1' : t === 'links' ? 'links1' : 'subs1' ];
      const g2 = LAST.json.geometry[ t === 'nodes' ? 'nodes2' : t === 'links' ? 'links2' : 'subs2' ];

      const geo = (g2 && g2[id] !== undefined) ? g2[id] : (g1 ? g1[id] : undefined);

      if (!geo) return;
      if (t === 'nodes'){
        const ll = xyToLatLng(geo[0], geo[1]);
        L.circleMarker(ll, { radius:10, color:C.select, weight:4, fill:false, opacity:.95 }).addTo(layers.select);
        map.panTo(ll, { animate:true });
      } else if (t === 'links') {
        const ll = geo.map(p=>xyToLatLng(p[0],p[1]));
        L.polyline(ll, { color:C.select, weight:8, opacity:.8 }).addTo(layers.select);
        map.fitBounds(L.latLngBounds(ll), { padding:[20,20] });
      } else if (t === 'subs'){
        const ll = geo.map(p=>xyToLatLng(p[0],p[1]));
        L.polygon(ll, { color:C.select, weight:5, fill:false, opacity:.95 }).addTo(layers.select);
        map.fitBounds(L.latLngBounds(ll), { padding:[20,20] });
      }
    }

    function cycleMapPopup(direction) {
      lastClickIndex = (lastClickIndex + direction + lastClickedElements.length) % lastClickedElements.length;
      map.closePopup();
      showMapPopup(lastClickLatLng, lastClickedElements, false);
    }

    function generatePopupContent(section, id) {
      const { diffs, headers, renames } = LAST.json || {};
      const d = diffs?.[section] || { added:{}, removed:{}, changed:{} };

      const isAdded   = d.added && Object.prototype.hasOwnProperty.call(d.added, id);
      const isRemoved = d.removed && Object.prototype.hasOwnProperty.call(d.removed, id);
      const changeType = isAdded ? 'Added' : isRemoved ? 'Removed' : 'Changed';

      const renameTo = renames?.[section]?.[id];
      let html = `<div style="font-weight:bold;font-size:14px;border-bottom:1px solid #eee;padding-bottom:4px;margin-bottom:6px;">${escapeHtml(section)}: ${escapeHtml(id)}</div>`;
      html += `<div style="margin-bottom:6px;"><span class="pill ${changeType.toLowerCase()}">${changeType}</span>`;
      if (renameTo) {
        html += `<span style="margin-left:4px;font-size:12px;color:#555;">(Renamed to ${escapeHtml(renameTo)})</span>`;
      }
      html += `</div>`;

      if (changeType === 'Changed') {
        const hdrs = relabelHeaders(section, headers?.[section] || []);
        const oldArr = d.changed[id]?.[0] || [];
        const newArr = d.changed[id]?.[1] || [];
        const maxLen = Math.max(oldArr.length, newArr.length);
        let changesHtml = '<ul style="margin:0;padding-left:18px;font-size:12px;">';
        let changeCount = 0;
        for (let i = 0; i < maxLen; i++) {
          const ov = oldArr[i] ?? "";
          const nv = newArr[i] ?? "";
          if (ov !== nv) {
            changeCount++;
            const fieldName = hdrs[i+1] || `Field ${i+1}`;
            changesHtml += `<li style="margin-bottom:4px;"><strong>${escapeHtml(fieldName)}:</strong> ${escapeHtml(ov)} → ${escapeHtml(nv)}</li>`;
          }
        }
        if (changeCount > 0) {
          html += changesHtml + '</ul>';
        } else {
          html += '<div style="font-size:12px;color:#666;">No parameter changes found.</div>';
        }
      }

      return html;
    }

    function showMapPopup(latlng, elements, isNewClick = true) {
      if (!elements || elements.length === 0) return;

      if (isNewClick) {
        lastClickIndex = 0;
        lastClickedElements = elements;
        lastClickLatLng = latlng;
      }

      if (isNewClick && JSON.stringify(elements) === JSON.stringify(lastClickedElements)) {
         lastClickIndex = (lastClickIndex + 1) % elements.length;
      }

      const selected = elements[lastClickIndex];
      const { id, section } = selected;

      const content = generatePopupContent(section, id);
      const cycleText = elements.length > 1 ? `<div style="display:flex;justify-content:space-between;align-items:center;font-size:11px;color:#777;margin-top:8px;padding-top:4px;border-top:1px solid #f0f0f0;">
        <button onclick="cycleMapPopup(-1)" style="padding:2px 6px;font-size:14px;">‹</button>
        <span>${lastClickIndex + 1} of ${elements.length}</span>
        <button onclick="cycleMapPopup(1)" style="padding:2px 6px;font-size:14px;">›</button>
      </div>` : "";

      L.popup({ minWidth: 250, maxWidth: 400 })
        .setLatLng(latlng)
        .setContent(content + cycleText)
        .openOn(map);

      highlightElement(section, id);
    }

    let lastClickedElements = [];
    let lastClickIndex = 0;
    let lastClickLatLng = null;

    function findNearbyElements(latlng) {
      const nearby = [];
      const toleranceInFeet = 20;
      const toleranceInMeters = toleranceInFeet * 0.3048;

      map.eachLayer(layer => {
        if (!layer.swmmInfo) return;

        let distance = Infinity;
        if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {
          distance = latlng.distanceTo(layer.getLatLng());
        } else if (layer instanceof L.Polyline) {
          const latlngs = layer.getLatLngs();
          for (const p of (Array.isArray(latlngs[0]) ? latlngs.flat() : latlngs)) {
            distance = Math.min(distance, latlng.distanceTo(p));
          }
        } else if (layer instanceof L.Polygon) {
          if (layer.getBounds().contains(latlng)) distance = 0; // Prioritize clicks inside a polygon
        }

        if (distance < toleranceInMeters) {
          nearby.push(layer.swmmInfo);
        }
      });
      return nearby;
    }

    map.on('click', (e) => {
      const clickedElements = findNearbyElements(e.latlng);
      if (clickedElements.length > 0) showMapPopup(e.latlng, clickedElements, true);
    });

    const worker = new Worker("worker.js");
    function setStatus(s){ document.getElementById('status').textContent = s; }
    worker.onmessage = (ev)=>{
      const { type, payload, error } = ev.data || {};
      if (type === "ready") { setStatus("Ready."); return; }
      if (type === "progress") { setStatus(payload); return; }
      if (type === "error") { setStatus(error || "Error"); alert(error); return; }
      if (type === "result") {
        try {
          const json = JSON.parse(payload);
          LAST.json = json;
          renderSections(json);
          drawGeometry(json);
          setStatus("Done.");
        } catch (e) {
          console.error(e);
          setStatus("Failed to parse result.");
          alert("Failed to parse result JSON.");
        }
      }
    };
    worker.postMessage({ type:"init" });

    document.getElementById('go').addEventListener('click', async ()=>{
      const f1 = document.getElementById('f1').files?.[0];
      const f2 = document.getElementById('f2').files?.[0];
      if (!f1 || !f2) { alert("Please choose both INP files."); return; }
      setStatus("Reading files…");
      const [b1, b2] = await Promise.all([f1.arrayBuffer(), f2.arrayBuffer()]);
      setStatus("Running comparison…");
      worker.postMessage({ type:"compare", file1: b1, file2: b2 }, [b1, b2]);
    });

    ["fAdded","fRemoved","fChanged","search"].forEach(id=>{
      document.getElementById(id).addEventListener(id==="search"?"input":"change", ()=>{
        if (!LAST.currentSection) return;
        renderTableFor(LAST.currentSection);
      });
    });

    function openDetail(section, id){
      const { diffs, headers, renames, hydrographs } = LAST.json || {};
      const d = diffs?.[section] || { added:{}, removed:{}, changed:{} };
      const titleEl = document.getElementById('modalTitle');
      const metaEl = document.getElementById('modalMeta');
      const grid = document.getElementById('modalGrid');
      const onlyChangedBox = document.getElementById('onlyChangedBox');

      if (section === "HYDROGRAPHS" && id.includes(" ")) {
        const [hydro, month] = id.split(" ");
        titleEl.textContent = `HYDROGRAPH · ${hydro} · ${month}`;
        grid.innerHTML = "";

        const params = ["R","T","K","Dmax","Drecov","Dinit"];
        const responses = ["Short","Medium","Long"];

        const h1 = (hydrographs?.file1 || {});
        const h2 = (hydrographs?.file2 || {});
        function getVals(dict, resp) {
          return (dict[`${hydro} ${month} ${resp}`] || ["","","","","",""]).slice(0,6);
        }

        function fmtNum(x){
          const v = Number(x);
          if (!isFinite(v)) return (x && x !== "") ? escapeHtml(x) : "—";
          const s = v.toLocaleString(undefined, { minimumFractionDigits: 3, maximumFractionDigits: 3 });
          return s === "-0.000" ? "0.000" : s;
        }

        function deltaCell(ov, nv){
          if ((ov ?? "") === (nv ?? "")) return `<span class="num">${fmtNum(nv)}</span>`;
          const vo = Number(ov), vn = Number(nv);
          const hasNums = isFinite(vo) && isFinite(vn);
          const delta = hasNums ? vn - vo : null;
          const dTxt = hasNums ? ` <span class="plusminus">(${delta >= 0 ? "+" : ""}${fmtNum(delta)})</span>` : "";
          const oTxt = (ov !== "" && ov !== undefined) ? fmtNum(ov) : "—";
          const nTxt = (nv !== "" && nv !== undefined) ? fmtNum(nv) : "—";
          return `<span class="delta"><span class="old">${oTxt}</span><span class="arrow">→</span><span class="diff">${nTxt}</span>${dTxt}</span>`;
        }

        const tbl = document.createElement("table");
        tbl.className = "modal-hydro";
        tbl.innerHTML = `<thead>
          <tr><th class="resp">Response</th>${params.map(p=>`<th>${p}</th>`).join("")}</tr>
        </thead><tbody></tbody>`;
        const tbody = tbl.querySelector("tbody");

        const showOnlyChanged = () => onlyChangedBox.checked;

        for (const resp of responses) {
          const oldVals = getVals(h1, resp);
          const newVals = getVals(h2, resp);
          const rowHasChange = oldVals.some((ov,i)=> (ov||"") !== (newVals[i]||""));
          if (showOnlyChanged() && !rowHasChange) continue;

          const tr = document.createElement("tr");
          tr.innerHTML = `<td style="padding:6px 8px;font-weight:600;">${resp}</td>` +
            params.map((_,i)=>{
              const ov = oldVals[i] || "";
              const nv = newVals[i] || "";
              return `<td>${deltaCell(ov, nv)}</td>`;
            }).join("");
          tbody.appendChild(tr);
        }

        metaEl.innerHTML = `<span class="tag">Hydrograph</span>`;
        grid.appendChild(tbl);
        onlyChangedBox.onchange = ()=> openDetail(section, id);
        document.getElementById('modalBackdrop').style.display = 'flex';
        return;
      }

      const hdrsRaw = (headers?.[section] || []).slice();
      const hdrsLabeled = relabelHeaders(section, hdrsRaw);

      const isAdded   = d.added && Object.prototype.hasOwnProperty.call(d.added, id);
      const isRemoved = d.removed && Object.prototype.hasOwnProperty.call(d.removed, id);
      const changeType = isAdded ? 'Added' : isRemoved ? 'Removed' : 'Changed';

      let oldArr = isAdded   ? [] : isRemoved ? (d.removed[id] || []) : (d.changed[id]?.[0] || []);
      let newArr = isRemoved ? [] : isAdded   ? (d.added[id]   || []) : (d.changed[id]?.[1] || []);

      titleEl.textContent = `${section} · ${id}`;
      const renameTo = renames?.[section]?.[id];
      metaEl.innerHTML = `<span class="tag">${changeType}</span>${renameTo ? `<span class="tag" style="margin-left:6px">Renamed ↦ ${renameTo}</span>`:''}`;

      const maxLen = Math.max(oldArr.length, newArr.length) + 1;
      while (hdrsLabeled.length < maxLen) hdrsLabeled.push(`Field ${hdrsLabeled.length+1}`);

      grid.innerHTML = `
        <div class="hdr">Field</div>
        <div class="hdr">Old</div>
        <div class="hdr">New</div>
      `;
      const showOnlyChanged = () => onlyChangedBox.checked;
      const pushRow = (label, oldV, newV)=>{
        const changed = (oldV||"") !== (newV||"");
        if (showOnlyChanged() && !changed) return;
        const oldCell = changed ? `<span class="cell-changed">${escapeHtml(oldV||"")}</span>` : escapeHtml(oldV||"");
        const newCell = changed ? `<span class="cell-changed">${escapeHtml(newV||"")}</span>` : escapeHtml(newV||"");
        grid.insertAdjacentHTML('beforeend', `<div>${escapeHtml(label)}</div><div>${oldCell}</div><div>${newCell}</div>`);
      };
      pushRow(hdrsLabeled[0] || "ID", id, id);
      for (let i=1;i<maxLen;i++) pushRow(hdrsLabeled[i] || `Field ${i}`, oldArr[i-1], newArr[i-1]);

      onlyChangedBox.onchange = ()=> openDetail(section, id);
      document.getElementById('modalBackdrop').style.display = 'flex';
    }

    function closeModal(){ document.getElementById('modalBackdrop').style.display='none'; }

    function copyRowJSON(){
      const section = LAST.currentSection;
      if (!section) return;
      const d = LAST.json?.diffs?.[section] || {};
      const rawTitle = document.getElementById('modalTitle').textContent;
      const parts = rawTitle.split('·').map(s=>s.trim());
      const id = parts[parts.length-1];

      let oldArr = [], newArr = [];
      if (d.added && Object.prototype.hasOwnProperty.call(d.added, id)) {
        newArr = d.added[id] || [];
      } else if (d.removed && Object.prototype.hasOwnProperty.call(d.removed, id)) {
        oldArr = d.removed[id] || [];
      } else if (d.changed && Object.prototype.hasOwnProperty.call(d.changed, id)) {
        oldArr = d.changed[id]?.[0] || [];
        newArr = d.changed[id]?.[1] || [];
      }

      const entry = {
        section,
        id,
        headers: relabelHeaders(section, (LAST.json?.headers?.[section] || [])),
        old: oldArr,
        new: newArr,
      };
      navigator.clipboard.writeText(JSON.stringify(entry, null, 2));
      alert("Row JSON copied.");
    }
  </script>
  
</body>
</html>
